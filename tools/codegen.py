#!/usr/bin/env python3

# TODO TEMPORARILY SHELVED
# May get used in the future

import json
import argparse
import csv
import os
import shlex
import sys

CMDLINE = shlex.join(sys.argv)

parser = argparse.ArgumentParser()
parser.add_argument("script", help = "Source generator Python script")
parser.add_argument("-o", "--output", action = "append", help = "Map outputs")
args = parser.parse_args()

if args.output is None:
    raise RuntimeError("At least one -o option must be provided")

output_map = {}
for o in args.output:
    key, val = o.split("=", 1)
    os.makedirs(os.path.dirname(val), exist_ok = True)
    output_map[key] = val

def check_output_file():
    global output_file
    if output_file is None:
        raise RuntimeError("You must select the output file key with o('...') before using this function")

global column_map
column_map = {}

global rows
rows = []

def c(*args):
    global column_map
    column_map = {}

    global rows
    rows = []

    i = 0
    for col in args:
        column_map[col] = i
        i += 1


def e(*args):
    global rows

    if len(args) % len(column_map) != 0:
        raise RuntimeError("Column count mismatch")

    row_data = list(args)
    
    for i in range(int(len(args) / len(column_map))):
        row = []
        for j in range(len(column_map)):
            row.append(args[i * len(column_map) + j])

        rows.append(row)

def i():
    global rows

    for row in rows:
        def s(name):
            if name == "cmdline": return cmdline
            return row[column_map[name]]

        yield s

def cid(name):
    global column_name
    return column_map[name]

global indent_level
indent_level = 0

global indent_str
indent_str = "    "

global line_start
line_start = True

class IndentContext:
    def __init__(self):
        pass

    def __enter__(self):
        global indent_level
        indent_level += 1

    def __exit__(self, type, value, traceback):
        global indent_level
        indent_level -= 1

def setind(indent):
    global indent_str
    indent_str = indent

def ind():
    return IndentContext()

def print_indent():
    global line_start
    if not line_start:
        return

    global output_file
    print(indent_level * indent_str, end = "", file = output_file)
    line_start = False

def l(*lines):
    print_indent()
    check_output_file()
    global output_file
    for l in lines:
        print(l, file = output_file)

    global line_start
    line_start = True

def a(*strings):
    print_indent()
    check_output_file()
    global output_file
    for s in strings:
        print(s, file = output_file, end = "")

    global line_start
    line_start = False

def w(*strings):
    print_indent()
    check_output_file()
    global output_file
    for i, s in enumerate(strings):
        print(s, file = output_file, end = "\n" if (i == len(strings) - 1) else "")

    global line_start
    line_start = True

def b():
    l("")

def n():
    l(
        f"/* Warning: DO NOT EDIT THIS FILE!",
        f" * This file has been automatically generated by the following command: ",
        f" *     {CMDLINE}",
        f" * CMake will automatically regenerate this file during build.",
        f" */",
    )
    b()

def rel2(from_key, to_key):
    return os.path.relpath(output_map[to_key], os.path.dirname(output_map[from_key]))

def rel(to_key):
    global output_key
    return rel2(output_key, to_key)


global output_file
output_file = None

def o(key):
    global output_file
    global output_key

    if output_file is not None:
        print(f">> Done with output '{output_key}'")
        output_file.close()

    output_key = key

    if key not in output_map:
        raise RuntimeError(f"Missing path for output '{key}'")

    print(f">> Working on output '{output_key}' ({output_map[key]})")

    output_file = open(output_map[key], "w")

try:
    exec(open(args.script, "r").read())
finally:
    if output_file is not None:
        print(f">> Done with output '{output_key}'")
        output_file.close()
        print(">> Codegen finished")
