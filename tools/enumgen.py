#!/usr/bin/env python3

import sys
import argparse
import csv
import shlex
import json
import os

def write_generated_notice(file):
    print(f"/* Warning: DO NOT EDIT THIS FILE!", file = file)
    print(f" * This file has been automatically generated by the following command: ", file = file)
    print(f" *     {cmdline}", file = file)
    print(f" * CMake will automatically regenerate this file during build.", file = file)
    print(f" */", file = file)

cmdline = shlex.join(sys.argv)

parser = argparse.ArgumentParser()
parser.add_argument("-p", "--prefix", default = "", help = "Enum entry prefix")
parser.add_argument("-n", "--name", required = True, help = "Name of the enum definition")
parser.add_argument("-c", "--csv", required = True, help = "CSV file containing enum definitions")
parser.add_argument("-1", "--first-row", action = "store_true", help = "Treat first row as an enum entry")
parser.add_argument("-H", "--header", required = True, help = "Path to output header file")
parser.add_argument("-S", "--source", required = True, help = "Path to output source file")
args = parser.parse_args()

print(f"Generating enum {args.name}")

class EnumEntry:
    def __init__(self, key, value, description):
        self.key = key
        self.value = value
        self.description = description

    def __repr__(self):
        return f"EnumEntry(key = {repr(self.key)}, value = {repr(self.value)}, description = {repr(self.description)})"


prev_value = -1

entries = []
with open(args.csv, "r") as csv_f:
    reader = csv.reader(csv_f, delimiter = ",", quotechar = "\"")

    first = True
    for row in reader:
        if not args.first_row and first:
            first = False
            continue

        key = row[0]
        value = row[1]
        description = row[2]

        if value.strip() == "":
            value = prev_value + 1
            prev_value = value
        else:
            value = int(value)
            prev_value = value

        entries.append(EnumEntry(key, value, description))
        print(f"{args.prefix}{key} = {value} ({description})")

if len(entries) == 0:
    raise RuntimeError("CSV enum list entry is empty")

last_entry = entries[-1]

header_rel_from_source = os.path.relpath(args.header, os.path.dirname(args.source))

os.makedirs(os.path.dirname(args.header), exist_ok = True)
with open(args.header, "w") as header_f:
    write_generated_notice(header_f)

    print("typedef enum {", file = header_f)
    for entry in entries:
        print(f"    {args.prefix}{entry.key} = {entry.value},", file = header_f)
    print(f"}} {args.name};", file = header_f)

    print(f"const char * {args.name}_name({args.name} value);", file = header_f)
    print(f"const char * {args.name}_desc({args.name} value);", file = header_f)
    print(f"{args.name} {args.name}_fromname(const char * name);", file = header_f)


os.makedirs(os.path.dirname(args.source), exist_ok = True)
with open(args.source, "w") as source_f:
    write_generated_notice(source_f)
    print(f"#include \"{header_rel_from_source}\"", file = source_f)
    print(f"#include <string.h>", file = source_f)

    print(f"const char * {args.name}_name({args.name} value) {{", file = source_f)
    print(f"    switch(value) {{", file = source_f)
    for entry in entries:
        print(f"    case {args.prefix}{entry.key}: return {json.dumps(entry.key)};", file = source_f)

    print(f"    default: return {json.dumps(last_entry.key)};", file = source_f)
    print(f"    }}", file = source_f)
    print(f"}}", file = source_f)

    print(f"const char * {args.name}_desc({args.name} value) {{", file = source_f)
    print(f"    switch(value) {{", file = source_f)
    for entry in entries:
        print(f"    case {args.prefix}{entry.key}: return {json.dumps(entry.description)};", file = source_f)

    print(f"    default: return {json.dumps(last_entry.description)};", file = source_f)
    print(f"    }}", file = source_f)
    print(f"}}", file = source_f)

    print(f"{args.name} {args.name}_fromname(const char * name) {{", file = source_f)
    for entry in entries:
        print(f"    if (strncmp(name, {json.dumps(entry.key)}, {len(entry.key) + 1}) == 0) return {args.prefix}{entry.key};", file = source_f)

    print(f"    return {args.prefix}{entry.key};", file = source_f)
    print(f"}}", file = source_f)
