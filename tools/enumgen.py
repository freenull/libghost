#!/usr/bin/env python3

import sys
import argparse
import csv
import shlex
import json
import os

def write_generated_notice(file, comment_start, comment_mid, comment_end):
    print(f"{comment_start} Warning: DO NOT EDIT THIS FILE!", file = file)
    print(f"{comment_mid} This file has been automatically generated by the following command: ", file = file)
    print(f"{comment_mid}     {cmdline}", file = file)
    print(f"{comment_mid} CMake will automatically regenerate this file during build.", file = file)
    print(f"{comment_end}", file = file)

cmdline = shlex.join(sys.argv)

parser = argparse.ArgumentParser()
parser.add_argument("-p", "--prefix", default = "", help = "Enum entry prefix")
parser.add_argument("-n", "--name", required = True, help = "Name of the enum definition")
parser.add_argument("-c", "--csv", required = True, help = "CSV file containing enum definitions")
parser.add_argument("-1", "--first-row", action = "store_true", help = "Treat first row as an enum entry")
parser.add_argument("-i", "--ident", action = "store_true", help = "Add a new column Ident between EnumKey and Value, generate _fromident and _ident")
parser.add_argument("-u", "--unknown", help = "Key of entry to represent an unknown value/invalid return")
parser.add_argument("-d", "--docname", help = "Human readable name of the enum to display in documentation")
parser.add_argument("-H", "--header", required = True, help = "Path to output header file")
parser.add_argument("-S", "--source", required = True, help = "Path to output source file")
parser.add_argument("-L", "--lua", help = "Optional path to output Lua source code (defining the enum with LuaJIT FFI)")
args = parser.parse_args()

print(f"Generating enum {args.name}")

class EnumEntry:
    def __init__(self, key, ident, value, description):
        self.key = key
        self.ident = ident
        self.value = value
        self.description = description

    def __repr__(self):
        return f"EnumEntry(key = {repr(self.key)}, value = {repr(self.value)}, description = {repr(self.description)})"


prev_value = -1
prev_bitflag = -1
all_bitflags = None

entries = []
with open(args.csv, "r") as csv_f:
    reader = csv.reader(csv_f, delimiter = ",", quotechar = "\"")

    first = True
    for row in reader:
        if len(row) == 0: continue
        if (row[0].strip().startswith("#")): continue

        if not args.first_row and first:
            first = False
            continue

        key = row[0]
        ident = None
        value = None
        description = None

        if args.ident:
            ident = row[1]
            value = row[2]
            description = row[3]
        else:
            value = row[1]
            description = row[2]

        if value.strip().startswith("::"):
            value = value.strip()[len("::"):]
            if value.strip() == "":
                value = 1 << (prev_bitflag + 1)
                prev_bitflag += 1
            else:
                value = 1 << int(value)
                prev_value = value
                prev_bitflag = int(value)

            all_bitflags = (all_bitflags + value) if all_bitflags is not None else value
        elif value.strip() == "":
            value = prev_value + 1
            prev_value = value
        else:
            value = int(value)
            prev_value = value

        entries.append(EnumEntry(key, ident, value, description))

        if args.ident:
            print(f"{args.prefix}{key} [{ident}] = {value} ({description})")
        else:
            print(f"{args.prefix}{key} = {value} ({description})")

if len(entries) == 0:
    raise RuntimeError("CSV enum list entry is empty")

last_entry = entries[-1]

unknown_entry = None
if args.unknown is not None:
    for entry in entries:
        if entry.key == args.unknown:
            unknown_entry = entry

    if unknown_entry is None:
        raise RuntimeError(f"Invalid unknown entry '{args.unknown}'")
else:
    unknown_entry = last_entry

header_rel_from_source = os.path.relpath(args.header, os.path.dirname(args.source))

def write_interface(f, args, entries, indent = ""):
    if args.docname is not None:
        print(f"{indent}/** @file {os.path.basename(args.header)} {args.docname} (autogenerated file) */", file = f)
        print(f"{indent}/** @brief {args.docname} */", file = f)
    print(f"{indent}typedef enum {{", file = f)
    for entry in entries:
        print(f"{indent}/** @brief {entry.description} */", file = f)
        print(f"{indent}    {args.prefix}{entry.key} = {entry.value},", file = f)

    if all_bitflags is not None:
        print(f"{indent}    {args.prefix}ALLFLAGS = {all_bitflags},", file = f)

    print(f"{indent}}} {args.name};", file = f)

    print(f"{indent}const char * {args.name}_name({args.name} value);", file = f)
    print(f"{indent}const char * {args.name}_desc({args.name} value);", file = f)
    print(f"{indent}{args.name} {args.name}_fromname(const char * name);", file = f)

    if args.ident:
        print(f"const char * {args.name}_ident({args.name} value);", file = f)
        print(f"{args.name} {args.name}_fromident(const char * ident);", file = f)

header_dirname = os.path.dirname(args.header)
if header_dirname != "":
    os.makedirs(header_dirname, exist_ok = True)
with open(args.header, "w") as header_f:
    write_generated_notice(header_f, "/*", " *", " */")
    write_interface(header_f, args, entries)

source_dirname = os.path.dirname(args.source)
if source_dirname != "":
    os.makedirs(source_dirname, exist_ok = True)
with open(args.source, "w") as source_f:
    write_generated_notice(source_f, "/*", " *", " */")
    print(f"#include \"{header_rel_from_source}\"", file = source_f)
    print(f"#include <string.h>", file = source_f)

    print(f"const char * {args.name}_name({args.name} value) {{", file = source_f)
    print(f"    switch(value) {{", file = source_f)
    for entry in entries:
        print(f"    case {args.prefix}{entry.key}: return {json.dumps(entry.key)};", file = source_f)
    if all_bitflags is not None:
        print(f"    case {args.prefix}ALLFLAGS: return {json.dumps(unknown_entry.key)};", file = source_f)

    print(f"    default: return {json.dumps(unknown_entry.key)};", file = source_f)
    print(f"    }}", file = source_f)
    print(f"}}", file = source_f)

    print(f"const char * {args.name}_desc({args.name} value) {{", file = source_f)
    print(f"    switch(value) {{", file = source_f)
    for entry in entries:
        print(f"    case {args.prefix}{entry.key}: return {json.dumps(entry.description)};", file = source_f)
    if all_bitflags is not None:
        print(f"    case {args.prefix}ALLFLAGS: return {json.dumps(unknown_entry.description)};", file = source_f)

    print(f"    default: return {json.dumps(unknown_entry.description)};", file = source_f)
    print(f"    }}", file = source_f)
    print(f"}}", file = source_f)

    print(f"{args.name} {args.name}_fromname(const char * name) {{", file = source_f)
    for entry in entries:
        print(f"    if (strncmp(name, {json.dumps(entry.key)}, {len(entry.key) + 1}) == 0) return {args.prefix}{entry.key};", file = source_f)

    print(f"    return {args.prefix}{unknown_entry.key};", file = source_f)
    print(f"}}", file = source_f)

    if args.ident:
        print(f"{args.name} {args.name}_fromident(const char * ident) {{", file = source_f)
        for entry in entries:
            print(f"    if (strncmp(ident, {json.dumps(entry.ident)}, {len(entry.ident) + 1}) == 0) return {args.prefix}{entry.key};", file = source_f)

        print(f"    return {args.prefix}{unknown_entry.key};", file = source_f)
        print(f"}}", file = source_f)

        print(f"const char * {args.name}_ident({args.name} value) {{", file = source_f)
        print(f"    switch(value) {{", file = source_f)
        for entry in entries:
            print(f"    case {args.prefix}{entry.key}: return {json.dumps(entry.ident)};", file = source_f)
        if all_bitflags is not None:
            print(f"    case {args.prefix}ALLFLAGS: return NULL;", file = source_f)

        print(f"    default: return NULL;", file = source_f)
        print(f"    }}", file = source_f)
        print(f"}}", file = source_f)

if args.lua is not None:
    lua_dirname = os.path.dirname(args.lua)
    if lua_dirname != "":
        os.makedirs(lua_dirname, exist_ok = True)
    with open(args.lua, "w") as lua_f:
        write_generated_notice(lua_f, "--[[", "    ", "--]]")
        print(f"require(\"ffi\").cdef [[", file = lua_f)
        write_interface(lua_f, args, entries, indent = "    ")
        print(f"]]", file = lua_f)
